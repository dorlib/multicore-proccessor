אוניברסיטת תל-אביב, הפקולטה להנדסה
פרויקט בקורס: ארכיטקטורה של מחשבים 0512.4461
שנת הלימודים תשפ"ו, סמסטר א'
בפרויקט נממש סימולטור של מעבד הכולל 4 ליבות אשר רצות במקביל1:
* Core 0 / IMEM 0 / Cache 0
* Core 1 / IMEM 1 / Cache 1
* Core 2 / IMEM 2 / Cache 2
* Core 3 / IMEM 3 / Cache 3
* Bus (MESI cache coherency protocol)
* Main Memory
כל ליבה הינה מצונררת, כוללת זיכרון הוראות SRAM פרטי, ומטמון נתונים פרטי2. הליבות מחוברות באמצעות BUS העובד בפרוטוקול קוהרנטיות MESI לזיכרון ראשי משותף3.
רגיסטרים
כל ליבה מכילה 16 רגיסטרים, שכל אחד מהם ברוחב 32 ביטים4.
רגיסטר מספר 1 הינו רגיסטר מיוחד שלא ניתן לכתוב אליו, ותמיד מכיל את שדה ה- immediate, לאחר בצוע sign extension, כפי שקודד בהוראת האסמבלי5. הוא מתעדכן עבור כל הוראה כחלק מפענוח ההוראה. רגיסטר 0 הינו זהותית אפס6. הוראות אשר כותבות לרגיסטר 0 לא משנות את ערכו7.
זיכרון הוראות
לכל ליבה זיכרון הוראות SRAM פרטי ברוחב 32 סיביות ובעומק 1024 שורות8. רגיסטר ה- PC לכן הינו ברוחב 10 ביטים, והוראות עוקבות מקדמות את PC באחד9.
צנרת
בכל ליבה יש שימוש ב- delay slot, והצנרת כוללת 5 שלבים10:
Fetch -> Decode -> Execute -> Mem -> Write Back
אין שימוש במעקפים11. בניגוד לצנרת מיפס שלמדנו, אין שימוש בחצאי מחזורי שעון בגישה למערך הרגיסטרים אלא במחזור שעון שלם. בכל מחזור שעון ניתן לבצע שלוש קריאות ממערך הרגיסטרים + כתיבה במקביל, אבל את הדאטא שכותבים במחזור שעון מסוים נקבל בקריאה רק במחזור השעון הבא12.
* Branch Resolution מתבצע בשלב הפענוח13.
* ההוראות נקראות מזיכרון הוראות SRAM פנימי לליבה במחזור שעון בודד14.
* פיתרון Data Hazards בין הוראות מתבצע ע"י Stall של ההוראה התלויה בשלב הפענוח15.
* במקרה של החטאה במטמון הנתונים, מתבצע Stall של ההוראה שפנתה למטמון בשלב ה- Mem16.
מטמון נתונים
בכל ליבה יש מטמון נתונים במיפוי ישיר בגודל 512 מילים17. זמן הפגיעה במטמון הינו מחזור שעון בודד, גודל הבלוק הינו 8 מילים, ומדיניות הכתיבה הינה write back, write allocate18.
המטמון ממומש באמצעות שני זכרונות SRAM:
1. הזיכרון הראשון DSRAM, הינו ברוחב 32 ביטים ובעומק 512 מילים, ומכיל את הדאטא השמור במטמון19.
2. הזיכרון השני, TSRAM, מכיל 64 שורות, כאשר כל שורה מכילה עבור כל בלוק במטמון את התג ואת מצב פרוטוקול הקוהרנטיות MESI20:
קידוד MESI (ביטים 13:12):
0: Invalid, 1: Shared, 2: Exclusive, 3: Modified.
מבנה ה-TSRAM:
| 13:12 | 11:0 |
| :--- | :--- |
| MESI | Tag |
בתחילת הריצה זכרונות ה-TSRAM ו- DSRAM מאופסים21.
זיכרון ראשי ו- MESI BUS
הגישה לנתונים הינה למילים בלבד (אין תמיכה בבתים). מרחב כתובות הנתונים הינו 21 ביטים, וגודל הזיכרון הראשי הינו $2^{21}$ מילים22.
ה- BUS בין הליבות לזיכרון הראשי מכיל את הקווים הבאים23:
Name
	Bits
	Description
	bus_origid
	3 bits
	Originator of this transaction:


0: core 0


1: core 1


2: core 2


3: core 3


4: main memory
	bus_cmd
	2 bits
	0: no command


1: BusRd


2: BusRdX


3: Flush
	bus_addr
	21 bits
	Word address
	bus_data
	32 bits
	Word data
	bus_shared
	1 bit
	Set to 1 when answering a BusRd transaction if any of the cores has the data in the cache, otherwise set to 0.
	בכל מחזור שעון על קווי הבס יש טראנסקציה בודדת. במידה ומספר מטמונים רוצים לפנות לבס, מתבצעת ארביטרציה הוגנת בשיטת Round-Robin (הליבה האחרונה שקיבלה גישה היא כעת בעדיפות אחרונה)24.
לא תינתן גישה לבס לליבה מסויימת כל עוד הבס תפוס או כל עוד טראנסקציה קודמת מסוג BusRd או BusRdX לא הסתיימה ע"י טראנסקציית Flush25.
מי שיוצר את הטראנסקצייה וכותב לקווי הבס במחזור שעון זה (ליבה או הזיכרון הראשי) ממלא קוד בקו bus_origid26.
הוראות BusRd ו- BusRdX מעבירות כפרמטר את כתובת המילה בזיכרון הראשי27.
במידה והדאטא עדכני בזיכרון הראשי, הזיכרון הראשי יחזיר את הבלוק שכולל את המילה באמצעות הוראות Flush28.
המילה הראשונה בבלוק תוחזר בהשהייה של 16 מחזורי שעון לאחר קבלת הוראת הקריאה, ושאר המילים בבלוק במחזורי שעון עוקבים29. הדאטא יוחזר בקווי ה- bus_data וכתובת המילה בזיכרון הראשי ב- bus_addr30.
עבור BusRd, במתן ההוראה לבס, bus_shared מאותחל לאפס. כחלק ממנגנון ה- Snooping כל מטמון בכל ליבה בודק האם יש פגיעה, ואם כן מעלה את קו ה- bus_shared ל- 1. כאשר הדאטא חוזר, בהסתמך על קו ה- bus_shared, מצב הפרוטוקול יקבע כ- Exclusive או Shared31.
במידה והדאטא העדכני נמצא במטמון של ליבה אחרת במצב Modified, ליבה זו תחזיר את הבלוק באמצעות הוראות Flush והזיכרון הראשי יתעדכן במקביל32.
סט ההוראות וקידודם
לכל ליבה יש פורמט אחיד לקידוד ההוראות לפי חלוקת הביטים הבאה33:
31:24
	23:20
	19:16
	15:12
	11:0
	Opcode
	rd
	rs
	rt
	immediate
	האופקודים הנתמכים ע"י המעבד ומשמעות כל הוראה נתונים בטבלה הבאה34:
Opcode
	Name
	Meaning
	0
	add
	$R[rd] = R[rs] + R[rt]$
	1
	sub
	$R[rd] = R[rs] - R[rt]$
	2
	and
	$R[rd] = R[rs] \& R[rt]$
	3
	or
	$R[rd] = R[rs] \| R[rt$
	4
	xor
	$R[rd] = R[rs] \wedge R[rt]$
	5
	mul
	$R[rd] = R[rs] * R[rt]$
	6
	sll
	$R[rd] = R[rs] \ll R[rt]$
	7
	sra
	$R[rd] = R[rs] \gg R[rt]$, arithmetic shift with sign extension
	8
	srl
	$R[rd] = R[rs] \gg R[rt]$, logical shift
	9
	beq
	if $(R[rs] == R[rt])$ $pc = R[rd]$ [low bits 9:0]
	10
	bne
	if $(R[rs] != R[rt])$ $pc = R[rd]$ [low bits 9:0]
	11
	blt
	if $(R[rs] < R[rt])$ $pc = R[rd]$ [low bits 9:0]
	12
	bgt
	if $(R[rs] > R[rt])$ $pc = R[rd]$ [low bits 9:0]
	13
	ble
	if $(R[rs] \le R[rt])$ $pc = R[rd]$ [low bits 9:0]
	14
	bge
	if $(R[rs] \ge R[rt])$ $pc = R[rd]$ [low bits 9:0]
	15
	jal
	$R[15]$ = next instruction address, $pc = R[rd][9:0]$
	16
	lw
	$R[rd] = MEM[R[rs] + R[rt]]$
	17
	sw
	$MEM[R[rs] + R[rt]] = R[rd]$
	20
	halt
	Halt this core. Exit simulator when all cores reached halt and the pipelines are empty.
	סימולטור
הסימולטור מסמלץ את צנרות הליבות, המטמונים, והזיכרון הראשי. בתחילת הריצה כל ליבה מתחילה לרוץ החל מ- $PC=0$. סיום הריצה ויציאה מהסימולטור מתבצע כאשר כל הליבות בצעו את הוראת ה- HALT והצנרות התרוקנו35.
הסימולטור יכתב בשפת C ויקומפל לתוך command line application אשר מקבל 27 command line parameters לפי שורת ההרצה הבאה36:
sim.exe imem0.txt imem1.txt imem2.txt imem3.txt memin.txt memout.txt regout0.txt regout1.txt regout2.txt regout3.txt core0trace.txt core1trace.txt core2trace.txt core3trace.txt bustrace.txt dsram0.txt dsram1.txt dsram2.txt dsram3.txt tsram0.txt tsram1.txt tsram2.txt tsram3.txt stats0.txt stats1.txt stats2.txt stats3.txt
בנוסף יש לתמוך גם בהרצת sim.exe ללא פרמטרים, ואז שמות הקבצים נלקחים כ- default לפי השמות לעיל, מאותה ספרייה שבה נמצא הקובץ sim.exe37.
קבצי קלט:
* imem0.txt - imem3.txt: קבצי קלט בפורמט טקסט אשר כל אחד מהם מכיל את תוכן זיכרון ההוראות של הליבה המתאימה בתחילת הריצה38. כל שורה בקובץ מכילה תוכן שורה בזיכרון ההוראות, החל מכתובת אפס, בפורמט של 8 ספרות הקסאדצימליות39. במידה ומספר השורות בקובץ קטן מ- 1024, ההנחה הינה ששאר הזיכרון מעל הכתובת האחרונה שאותחלה בקובץ, מאופס40. ניתן להניח שקובץ הקלט תקין41.
* memin.txt: קובץ קלט בפורמט טקסט אשר מכיל את תוכן הזיכרון הראשי בתחילת הריצה42. כל שורה בקובץ מכילה תוכן שורה בזיכרון, החל מכתובת אפס, בפורמט של 8 ספרות הקסאדצימליות43. במידה ומספר השורות בקובץ קטן מ- $2^{21}$ ההנחה הינה ששאר הזיכרון מעל הכתובת האחרונה שאותחלה בקובץ, מאופס44. ניתן להניח שקובץ הקלט תקין45.
קבצי פלט:
* memout.txt: קובץ פלט, באותו פורמט כמו memin.txt, שמכיל את תוכן הזיכרון הראשי בסיום הריצה46.
* regout0.txt - regout3.txt: קבצי פלט, שמכילים את תוכן הרגיסטרים R2-R15 של הליבה המתאימה בסיום הריצה (שימו לב שאין להדפיס את הקבועים R0 ו- R1)47. כל שורה תיכתב באותו פורמט כמו שורה ב- memin.txt, ב-8 ספרות הקסאדצימליות48.
* core0trace.txt - core3trace.txt: קבצי פלט, המכילים מעקב אחר מצב הצנרת. 495051עבור כל ליבה, בכל מחזור שעון שלפחות אחד מהשלבים בצנרת פעיל, תודפס שורת טקסט המציינת איזו הוראה נמצאת בכל שלב בצנרת, וכמו כן תוכן מערך ה52רגיסטרים בפורמט הבא535455:5657
CYCLE FETCH DECODE EXEC MEM WB R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15
   * השדה CYCLE הינו מספר מחזור השעון ומודפס בבסיס דצימלי58.
   * השדות FETCH עד WB מכילים את ה- PC של ההוראה שנמצאת בשלב המתאים בצנרת ומודפסים ב- 3 ספרות הקסאדצימליות. במידה ושלב הצנרת אינו פעיל (למשל בעת מילוי הצנרת או כאשר יש בועית בצנרת בשלב זה) יש להדפיס שלושה סימני מינוס (---)59.
   * אח"כ יש את תוכן מערך הרגיסטרים (החל מרגיסטר R2) בתחילת מחזור השעון (ה- Q של הפליפלופים, לא כולל שינויים במחזור שעון זה), כאשר כל רגיסטר מודפס ב- 8 ספרות הקסאדצימליות60.
   * bustrace.txt: קובץ פלט, שמכיל את תוכן קווי ה- BUS בכל מחזור שעון שבו bus_cmd שונה מאפס בפורמט הבא:
CYCLE bus_origid bus_cmd bus_addr bus_data bus_shared
      * השדה CYCLE הינו מספר מחזור השעון ומודפס בבסיס דצימלי61.
      * שאר השדות מודפסים בהקסדצימלי (שדות bus_origid, bus_cmd, bus_shared בספרה בודדת, bus_addr ב- 6 ספרות ו- bus_data ב- 8 ספרות)62.
      * dsram0.txt - dsram3.txt: קבצי פלט, באותו פורמט כמו memin.txt, שכל אחד מהם מכיל את תוכן זיכרון ה- DSRAM של המטמון בליבה המתאימה בסיום הריצה, כאשר כל שורה מודפסת ב- 8 ספרות הקסאדצימליות63.
      * tsram0.txt - tsram3.txt: קבצי פלט, באותו פורמט כמו memin.txt, שכל אחד מהם מכיל את תוכן זיכרון ה- TSRAM של המטמון בליבה המתאימה בסיום הריצה, כאשר כל שורה מודפסת ב- 8 ספרות הקסאדצימליות64.
      * stats0.txt - stats3.txt: קבצי פלט, אשר מכילים סטטיסטיקות עבור כל ליבה. כל קובץ מכיל מספר שורות, כל שורה מכילה שם ומונה X בפורמט הבא, כאשר X דצימאלי65:
row contents
	explanation
	cycles X
	number of clock cycles the core was running till halt
	instructions X
	number of instructions executed
	read hit X
	number of cache read hits
	write hit X
	number of cache write hits
	read miss X
	number of cache read misses
	write miss X
	number of cache write misses
	decode stall X
	number of cycles a pipeline stall was inserted in decode stage
	mem stall X
	number of cycles a pipeline stall was inserted in mem stage
	דרישות הגשה
      1. יש להגיש קובץ דוקומנטציה של הפרויקט, חיצוני לקוד, בפורמט pdf, בשם project1_id1_id2_id3.pdf כאשר id הם מספרי תעודת הזהות שלכם66.
      2. הפרויקט יכתב בשפת התכנות סי. יש להקפיד שיהיו הערות בתוך הקוד המסבירות את פעולתו67.
      3. יש להגיש את הקוד ב- visual studio community edition בסביבת windows. יש להגיש את קובץ ה- solution, ולוודא שהקוד מתקמפל ורץ, כך שניתן יהיה לבנות אותו ע"י לחיצה על build solution. יש להגיש גם את ספריית ה- build הכולל את קובץ ה- executable הבנוי68.
      4. תוכניות בדיקה. הפרויקט שלכם יבדק בין השאר ע"י תוכניות בדיקה שלא תקבלו מראש, וגם ע"י תוכניות בדיקה שאתם תכתבו באסמבלי69. יש להגיש שלוש תוכניות בדיקה70:
      * א. תוכנית אשר רצה על 4 ליבות במקביל, כאשר כל ליבה מקדמת מונה בכתובת 0 בזיכרון הראשי (אשר מאותחל לאפס) 128 פעמים, אבל הקידום מתבצע בטור לפי סדר הליבות. כלומר: ליבה 0 מבצעת את הקידום הראשון, אח"כ ליבה 1 מבצעת את הקידום הבא, ואז ליבה 2, ואז ליבה 3, וחוזרים לליבה 071. בסיום הריצה יש לוודא כי הערך בכתובת 0 (שאמור להיות 512) נכתב חזרה לזיכרון הראשי (באמצעות אילוץ conflict miss)72.
      * ב. תוכנית המבצעת כפל של שתי מטריצות בגודל 16x16 (כל איבר במטריצת התוצאה הינו מכפלה סקלארית של שורה בעמודה), אשר רצה על ליבה בודדת, ליבה מספר 0. ערכי המטריצה הראשונה נמצאים בכתובות 0 עד 0xFF בזיכרון הראשי, והמטריצה השנייה בכתובות 0x100 עד 0x1FF. מטריצת התוצאה תיכתב לכתובות 0x200 עד 0x2FF. כל מטריצה מסודרת בזיכרון כמו בשפת סי: ערכי שורה ראשונה משמאל לימין, ואז עוברים לשורה הבאה וכך הלאה73. ניתן להניח שערכי המטריצות קטנים מספיק כך שלא יתרחש overflow74.
      * ג. בצוע כפל של אותן המטריצות כמו בתוכנית בדיקה ב', אבל על כל 4 הליבות במקביל, כאשר כל ליבה מבצעת חלק מהחישוב. ינתן ניקוד גבוה יותר לזמן ריצה כולל נמוך יותר75.
      5. את תוכניות הבדיקה יש להגיש בשלוש תתי-ספריות בשמות: counter, mulserial, mulparallel76.
כל ספרייה תכיל 28 קבצים: את קובץ ההרצה sim.exe, את קבצי הקלט הדרושים להרצה, וכמו כן את קבצי הפלט שקיבלתם77:
sim.exe imem0.txt imem1.txt imem2.txt imem3.txt memin.txt memout.txt regout0.txt regout1.txt regout2.txt regout3.txt core0trace.txt core1trace.txt core2trace.txt core3trace.txt bustrace.txt dsram0.txt dsram1.txt dsram2.txt dsram3.txt tsram0.txt tsram1.txt tsram2.txt tsram3.txt stats0.txt stats1.txt stats2.txt stats3.txt 78
         1.